#3. identity
identity id generator works for the databases that supports identity or autoincrement columns like ms sql server or mysql database. Here the database is going to generate the id, and the identity id generator will fetch the id that is generated by the database	

notes:-
	1. supported dataTypes are int, short, long
	2. works for both multi-threaded and clustered environments 
	3. works with few databases only

4. sequence
sequence id generator is used for oracle database. oracle database doesnt support identity or autoincrement columns. Oracle has provided sequence datastructure to generate the sequence numbers that can be taken as a primary key column values for inserting the data into tables.
	
sequence id generator helps in querying/fetching the key from sequence, using that id generated the hibernate wll persist the data of an entity object

<id name="customerNo" column="customer_no">
	<generator class="sequence"/>
</id>

by default sequence id generator fetches the sequence value from hibernate_sequence. it is not recommended to use default sequence rather create a sequence per each table and use it for generating the primary key

so to let the sequence id generator use the specific sequence of the table we need to define sequence parameter configured with value as sequence name to be used

<id name="customerNo" column="customer_no">
	<generator class="sequence">
		<param name="sequence">customer_no_sequence</param>
	</generator>
</id>

#5. native
native id generator works native to the database on which our application is running. if we are running our application against mysql or mssqlserver database then native id generator works as identity id generator. if we are running our application against oracle database, then it works as sequence id generator

So switching between mysql/mssqlserver to oracle databases doesnt impact the mapping information we have written

<id name="customerNo" column="customer_no">
	<generator class="native">
		<param name="sequence">customer_sequence</param>
	</generator>
</id>
The above id generator definition works for both mysql/mssqlserver and oracle database

#6. guid
There are few databases that supports generating the unique id as a 32 character hexa decimal string that is uniquely computed based on various different parameters.
For eg.. oracle database has provided an function called sys_guid() which will generates the hexa decimal string which is unique from any other string that is generated across
select sys_guid() from dual

guid id generator works with only the databases that supports generating guid string as above. so guid id generators invokes/executes the database function and fetches the id with which the entity object will be persisted.
	
<id name="customerNo" column="customer_no">
	<generator class="guid"/>
</id>

notes:-
1. supported dataTypes are String/varchar2 only
2. the id generated is not human understandable or memorizable
3. works for multi-threaded and clustered environments
4. only works with few databases that support guid generation

#7. uuid
uuid works similar to guid in generating the suroggate key,the  only difference is it doesnt relies on underlying database to generate the id. 

	
#8. foreign
it used while working with direct one-to-one association mapping in fetching the primary key of an associated entity object and use it as a foreign key while storing the child entity

#9. select

triggers are block of code (procedure/function) that is being executed by the database upon performing an action or operation on the underlying tables
The triggers can be configured to execute either 
1. before the operation = changing the input values with which we want to perform operation
2. after the completing the operation = capturing database auditing

There are 2 types of triggers are there
1. statement level triggers = will be executed only once per the sql query that has been executed 
2. row level triggers = will be executed for each record that has been affected by the sql query execution

In older applications the developers relies on triggers for generating the primary key column values since these are quickest and safest way of generating the surrogate keys.
	
	














































